/**
 * Generates TypeScript type definitions from JSON Schema files.
 * Run with: npm run generate:types (uses tsx)
 *
 * This is a simplified generator. For production, consider using
 * json-schema-to-typescript or similar mature tools.
 */
import { mkdirSync, readFileSync, readdirSync, statSync, writeFileSync } from 'node:fs';
import { basename, dirname, join, relative } from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const SCHEMA_DIR = join(__dirname, '..', 'schemas', 'v1');
const OUTPUT_DIR = join(__dirname, '..', 'packages', 'types', 'src', 'generated');

// -- implement helper functions --

function findSchemaFiles(dir: string): string[] {
  const files: string[] = [];
  for (const entry of readdirSync(dir)) {
    const fullPath = join(dir, entry);
    if (statSync(fullPath).isDirectory()) {
      files.push(...findSchemaFiles(fullPath));
    } else if (entry.endsWith('.schema.json')) {
      files.push(fullPath);
    }
  }
  return files;
}

/** Convert JSON Schema type to TypeScript type */
function schemaTypeToTS(schema: Record<string, unknown>): string {
  if (schema.enum) {
    return (schema.enum as unknown[]).map((v) => JSON.stringify(v)).join(' | ');
  }
  if (schema.const !== undefined) {
    return JSON.stringify(schema.const);
  }

  const type = schema.type as string | string[] | undefined;
  if (Array.isArray(type)) {
    return type.map((t) => jsonTypeToTS(t)).join(' | ');
  }

  switch (type) {
    case 'string':
      return 'string';
    case 'number':
    case 'integer':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'null':
      return 'null';
    case 'array': {
      const items = schema.items as Record<string, unknown> | undefined;
      if (items) return `(${schemaTypeToTS(items)})[]`;
      return 'unknown[]';
    }
    case 'object': {
      if (schema.properties) return 'Record<string, unknown>'; // simplified
      if (schema.additionalProperties === true) return 'Record<string, unknown>';
      return 'Record<string, unknown>';
    }
    default:
      if (schema.$ref) return 'unknown'; // Would need ref resolution
      return 'unknown';
  }
}

function jsonTypeToTS(type: string): string {
  switch (type) {
    case 'string':
      return 'string';
    case 'number':
    case 'integer':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'null':
      return 'null';
    case 'array':
      return 'unknown[]';
    case 'object':
      return 'Record<string, unknown>';
    default:
      return 'unknown';
  }
}

/** Convert a schema to a TypeScript interface */
function schemaToInterface(name: string, schema: Record<string, unknown>): string {
  const lines: string[] = [];
  const description = schema.description as string | undefined;

  if (description) {
    lines.push(`/** ${description} */`);
  }

  lines.push(`export interface ${name} {`);

  const properties = schema.properties as Record<string, Record<string, unknown>> | undefined;
  const required = new Set((schema.required as string[]) ?? []);

  if (properties) {
    for (const [propName, propSchema] of Object.entries(properties)) {
      const optional = required.has(propName) ? '' : '?';
      const tsType = schemaTypeToTS(propSchema);
      const propDesc = propSchema.description as string | undefined;
      if (propDesc) {
        lines.push(`  /** ${propDesc} */`);
      }
      lines.push(`  ${propName}${optional}: ${tsType};`);
    }
  }

  lines.push('}');
  return lines.join('\n');
}

/** Convert schema filename to PascalCase interface name */
function fileNameToInterfaceName(fileName: string, category?: string): string {
  const base = basename(fileName, '.schema.json');
  const parts = base.split('-').map((p) => p.charAt(0).toUpperCase() + p.slice(1));
  const prefix = category ? category.charAt(0).toUpperCase() + category.slice(1) : '';
  return `${prefix + parts.join('')}Data`;
}

function main() {
  // Ensure output directory exists
  mkdirSync(OUTPUT_DIR, { recursive: true });

  const schemaFiles = findSchemaFiles(SCHEMA_DIR);
  console.log(`Found ${schemaFiles.length} schema files`);

  const interfaces: string[] = [];
  interfaces.push('// Auto-generated from JSON schemas. Do not edit manually.');
  interfaces.push('// Generated by scripts/generate-types.ts\n');

  // Process event schemas
  const eventDir = join(SCHEMA_DIR, 'events');
  try {
    for (const category of readdirSync(eventDir)) {
      const categoryPath = join(eventDir, category);
      if (!statSync(categoryPath).isDirectory()) continue;

      for (const file of readdirSync(categoryPath)) {
        if (!file.endsWith('.schema.json')) continue;
        // Skip shared object schemas (product, promotion, media-object)
        if (['product', 'promotion', 'media-object'].some((s) => file.startsWith(s))) continue;

        const filePath = join(categoryPath, file);
        try {
          const schema = JSON.parse(readFileSync(filePath, 'utf-8'));
          const interfaceName = fileNameToInterfaceName(file, category);
          interfaces.push(schemaToInterface(interfaceName, schema));
          interfaces.push('');
        } catch (err) {
          console.warn(
            `  Warning: Could not process ${relative(SCHEMA_DIR, filePath)}: ${(err as Error).message}`,
          );
        }
      }
    }
  } catch {
    console.warn('  Warning: events directory not found');
  }

  const output = interfaces.join('\n');
  const outputFile = join(OUTPUT_DIR, 'index.ts');
  writeFileSync(outputFile, output, 'utf-8');
  console.log(`\nGenerated types written to ${relative(process.cwd(), outputFile)}`);
  console.log('Done! âœ“');
}

main();
